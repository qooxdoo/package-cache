{"version":3,"sources":["../src/jsdocUtils.js"],"names":["getFunctionParameterNames","functionNode","getParamName","param","_","has","name","left","type","get","argument","parameter","Error","params","map","getJsdocParameterNamesDeep","jsdoc","targetTagName","jsdocParameterNames","filter","tags","tag","getJsdocParameterNames","includes","getPreferredTagName","tagPreference","values","preferredTagName","findKey","tagNames","aliases","isValidTag","definedTags","validTagNames","keys","concat","flatten","additionalTags","allTags","hasTag","targetTagLower","toLowerCase","some","doc","hasATag","targetTagNames","hasDefinedTypeReturnTag","tagType","trim","namepathDefiningTags","namepathPointingTags","isNamepathDefiningTag","tagName","isNamepathPointingTag","checkSeesForNamepaths","isNamepathTag","potentiallyEmptyNamepathTags","isPotentiallyEmptyNamepathTag","tagsWithTypes","closureTagsWithTypes","tagsWithTypesAliases","isTagWithType","hasReturnValue","node","expression","body","bodyNode","consequent","alternate","block","handler","finalizer","cases","someCase","parseClosureTemplateTag","source","split","enforcedContexts","context","defaultContexts","options","contexts","getContextObject","checkJsdoc","reduce","obj","prop","filterTags","tagsWithNamesAndDescriptions","getTagsByType","descName","tagsWithoutNames","tagsWithNames","tagWithName","push","getAncestor","sourceCode","nde","depth","idx","prevToken","getTokenBefore","getIndent","indent","text","match","charAt"],"mappings":"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","sourcesContent":["import _ from 'lodash';\nimport tagNames from './tagNames';\n\nconst getFunctionParameterNames = (functionNode : Object) : Array<string> => {\n  const getParamName = (param) => {\n    if (_.has(param, 'name')) {\n      return param.name;\n    }\n\n    if (_.has(param, 'left.name')) {\n      return param.left.name;\n    }\n\n    if (param.type === 'ObjectPattern' || _.get(param, 'left.type') === 'ObjectPattern') {\n      return '<ObjectPattern>';\n    }\n\n    if (param.type === 'ArrayPattern' || _.get(param, 'left.type') === 'ArrayPattern') {\n      return '<ArrayPattern>';\n    }\n\n    if (param.type === 'RestElement') {\n      return param.argument.name;\n    }\n\n    if (param.type === 'TSParameterProperty') {\n      return getParamName(param.parameter);\n    }\n\n    throw new Error('Unsupported function signature format.');\n  };\n\n  return functionNode.params.map(getParamName);\n};\n\n/**\n * Gets all parameter names, including those that refer to a path, e.g. \"@param foo; @param foo.bar\".\n */\nconst getJsdocParameterNamesDeep = (jsdoc : Object, targetTagName : string) : Array<string> => {\n  let jsdocParameterNames;\n\n  jsdocParameterNames = _.filter(jsdoc.tags, {\n    tag: targetTagName\n  });\n\n  jsdocParameterNames = _.map(jsdocParameterNames, 'name');\n\n  return jsdocParameterNames;\n};\n\nconst getJsdocParameterNames = (jsdoc : Object, targetTagName : string) : Array<string> => {\n  let jsdocParameterNames;\n\n  jsdocParameterNames = getJsdocParameterNamesDeep(jsdoc, targetTagName);\n\n  jsdocParameterNames = jsdocParameterNames.filter((name) => {\n    return !name.includes('.');\n  });\n\n  return jsdocParameterNames;\n};\n\nconst getPreferredTagName = (name : string, tagPreference : Object = {}) : string => {\n  if (_.values(tagPreference).includes(name)) {\n    return name;\n  }\n\n  if (_.has(tagPreference, name)) {\n    return tagPreference[name];\n  }\n\n  const preferredTagName = _.findKey(tagNames, (aliases) => {\n    return aliases.includes(name);\n  });\n  if (preferredTagName) {\n    return preferredTagName;\n  }\n\n  return name;\n};\n\nconst isValidTag = (name : string, definedTags : Array) : boolean => {\n  const validTagNames = _.keys(tagNames).concat(_.flatten(_.values(tagNames)));\n  const additionalTags = definedTags;\n  const allTags = validTagNames.concat(additionalTags);\n\n  return allTags.includes(name);\n};\n\nconst hasTag = (jsdoc : Object, targetTagName : string) : boolean => {\n  const targetTagLower = targetTagName.toLowerCase();\n\n  return _.some(jsdoc.tags, (doc : Object) => {\n    return doc.tag.toLowerCase() === targetTagLower;\n  });\n};\n\nconst hasATag = (jsdoc : Object, targetTagNames : Array) : boolean => {\n  return targetTagNames.some((targetTagName) => {\n    return hasTag(jsdoc, targetTagName);\n  });\n};\n\n/**\n * Checks if the JSDoc comment declares a return value.\n *\n * @param {JsDocTag} tag\n *   the tag which should be checked.\n * @returns {boolean}\n *   true in case a return value is declared; otherwise false.\n */\nconst hasDefinedTypeReturnTag = (tag) => {\n  // The function should not continue in the event @returns is not defined...\n  if (typeof tag === 'undefined' || tag === null) {\n    return false;\n  }\n\n  // .. same applies if it declares `@returns {undefined}` or `@returns {void}`\n  const tagType = tag.type.trim();\n  if (tagType === 'undefined' || tagType === 'void') {\n    return false;\n  }\n\n  // In any other case, something must be returned, and\n  // a return statement is expected\n  return true;\n};\n\nconst namepathDefiningTags = [\n  // NOT USEFUL WITHOUT NAMEPATH\n  'external', 'host',\n  'name',\n  'typedef',\n\n  // MAY BE USEFUL WITHOUT NAMEPATH\n  'event',\n\n  // MAY BE USEFUL WITHOUT NAMEPATH (OR\n  //  BLOCK CAN USE NAMEPATH FROM ELSEWHERE)\n  'class', 'constructor',\n  'constant', 'const',\n  'callback',\n  'function', 'func', 'method',\n  'interface',\n  'member', 'var',\n  'mixin',\n  'namespace'\n];\n\nconst namepathPointingTags = [\n  // NOT USEFUL WITHOUT NAMEPATH\n  'alias',\n  'augments', 'extends',\n\n  // `borrows` has a different format, however, so needs special parsing\n  'borrows',\n  'lends',\n  'memberof',\n  'memberof!',\n  'mixes',\n  'this',\n\n  // MAY BE USEFUL WITHOUT NAMEPATH\n  'emits',\n  'fires',\n  'listens'\n];\n\nconst isNamepathDefiningTag = (tagName) => {\n  return namepathDefiningTags.includes(tagName);\n};\n\nconst isNamepathPointingTag = (tagName, checkSeesForNamepaths) => {\n  return namepathPointingTags.includes(tagName) ||\n    tagName === 'see' && checkSeesForNamepaths;\n};\n\nconst isNamepathTag = (tagName, checkSeesForNamepaths) => {\n  return isNamepathDefiningTag(tagName) ||\n    isNamepathPointingTag(tagName, checkSeesForNamepaths);\n};\n\nconst potentiallyEmptyNamepathTags = [\n  // These may serve some minor purpose when empty or\n  //  their namepath can be expressed elsewhere on the block\n  'event',\n  'callback',\n  'class', 'constructor',\n  'constant', 'const',\n  'function', 'func', 'method',\n  'interface',\n  'member', 'var',\n  'mixin',\n  'namespace',\n  'listens', 'fires', 'emits'\n];\n\nconst isPotentiallyEmptyNamepathTag = (tag) => {\n  return potentiallyEmptyNamepathTags.includes(tag);\n};\n\nlet tagsWithTypes = [\n  'class',\n  'constant',\n  'enum',\n  'implements',\n  'member',\n  'module',\n  'namespace',\n  'param',\n  'property',\n  'returns',\n  'throws',\n  'type',\n  'typedef',\n  'yields'\n];\n\nconst closureTagsWithTypes = [\n  'package', 'private', 'protected', 'public', 'static'\n];\n\nconst tagsWithTypesAliases = [\n  'constructor',\n  'const',\n  'var',\n  'arg',\n  'argument',\n  'prop',\n  'return',\n  'exception',\n  'yield'\n];\n\ntagsWithTypes = tagsWithTypes.concat(tagsWithTypesAliases, closureTagsWithTypes);\n\nconst isTagWithType = (tagName) => {\n  return tagsWithTypes.includes(tagName);\n};\n\n/**\n * Checks if a node has a return statement. Void return does not count.\n *\n * @param {object} node\n * @returns {boolean}\n */\n// eslint-disable-next-line complexity\nconst hasReturnValue = (node) => {\n  if (!node) {\n    return false;\n  }\n  switch (node.type) {\n  case 'FunctionExpression':\n  case 'FunctionDeclaration':\n  case 'ArrowFunctionExpression': {\n    return node.expression || hasReturnValue(node.body);\n  }\n  case 'BlockStatement': {\n    return node.body.some((bodyNode) => {\n      return bodyNode.type !== 'FunctionDeclaration' && hasReturnValue(bodyNode);\n    });\n  }\n  case 'WhileStatement':\n  case 'DoWhileStatement':\n  case 'ForStatement':\n  case 'ForInStatement':\n  case 'ForOfStatement':\n  case 'WithStatement': {\n    return hasReturnValue(node.body);\n  }\n  case 'IfStatement': {\n    return hasReturnValue(node.consequent) || hasReturnValue(node.alternate);\n  }\n  case 'TryStatement': {\n    return hasReturnValue(node.block) ||\n      hasReturnValue(node.handler && node.handler.body) ||\n      hasReturnValue(node.finalizer);\n  }\n  case 'SwitchStatement': {\n    return node.cases.some(\n      (someCase) => {\n        return someCase.consequent.some(hasReturnValue);\n      }\n    );\n  }\n  case 'ReturnStatement': {\n    // void return does not count.\n    if (node.argument === null) {\n      return false;\n    }\n\n    return true;\n  }\n  default: {\n    return false;\n  }\n  }\n};\n\n/** @param {string} tag */\n/*\nconst isInlineTag = (tag) => {\n  return /^(@link|@linkcode|@linkplain|@tutorial) /.test(tag);\n};\n*/\n\n/**\n * Parses GCC Generic/Template types\n *\n * @see {https://github.com/google/closure-compiler/wiki/Generic-Types}\n * @param {JsDocTag} tag\n * @returns {Array<string>}\n */\nconst parseClosureTemplateTag = (tag) => {\n  return tag.source\n    .split('@template')[1]\n    .split(',')\n    .map((type) => {\n      return type.trim();\n    });\n};\n\n/**\n * Checks user option for `contexts` array, defaulting to\n *   contexts designated by the rule. Returns an array of\n *   ESTree AST types, indicating allowable contexts.\n *\n * @param {*} context\n * @param {true|string[]} defaultContexts\n * @returns {string[]}\n */\nconst enforcedContexts = (context, defaultContexts) => {\n  const {\n    /* istanbul ignore next */\n    contexts = defaultContexts === true ? [\n      'ArrowFunctionExpression',\n      'FunctionDeclaration',\n      'FunctionExpression'\n    ] : defaultContexts\n  } = context.options[0] || {};\n\n  return contexts;\n};\n\n/**\n * @param {string[]} contexts\n * @param {Function} checkJsdoc\n */\nconst getContextObject = (contexts, checkJsdoc) => {\n  return contexts.reduce((obj, prop) => {\n    obj[prop] = checkJsdoc;\n\n    return obj;\n  }, {});\n};\n\nconst filterTags = (tags = [], filter) => {\n  return tags.filter(filter);\n};\n\nconst tagsWithNamesAndDescriptions = [\n  'param', 'arg', 'argument', 'property', 'prop',\n\n  // These two are parsed by our custom parser as though having a `name`\n  'returns', 'return'\n];\n\nconst getTagsByType = (tags, tagPreference) => {\n  const descName = getPreferredTagName('description', tagPreference);\n  const tagsWithoutNames = [];\n  const tagsWithNames = filterTags(tags, (tag) => {\n    const {tag: tagName} = tag;\n    const tagWithName = tagsWithNamesAndDescriptions.includes(tagName);\n    if (!tagWithName && tagName !== descName) {\n      tagsWithoutNames.push(tag);\n    }\n\n    return tagWithName;\n  });\n\n  return {\n    tagsWithNames,\n    tagsWithoutNames\n  };\n};\n\nconst getAncestor = (sourceCode, nde, depth, idx = 0) => {\n  if (idx === depth) {\n    return nde;\n  }\n  const prevToken = sourceCode.getTokenBefore(nde);\n  if (prevToken) {\n    return getAncestor(sourceCode, prevToken, depth, idx + 1);\n  }\n\n  return null;\n};\n\nconst getIndent = (sourceCode) => {\n  let indent = sourceCode.text.match(/^\\n*([ \\t]+)/);\n  /* istanbul ignore next */\n  indent = indent ? indent[1] + indent[1].charAt() : ' ';\n\n  return indent;\n};\n\nexport default {\n  enforcedContexts,\n  filterTags,\n  getAncestor,\n  getContextObject,\n  getFunctionParameterNames,\n  getIndent,\n  getJsdocParameterNames,\n  getJsdocParameterNamesDeep,\n  getPreferredTagName,\n  getTagsByType,\n  hasATag,\n  hasDefinedTypeReturnTag,\n  hasReturnValue,\n  hasTag,\n  isNamepathDefiningTag,\n  isNamepathTag,\n  isPotentiallyEmptyNamepathTag,\n  isTagWithType,\n  isValidTag,\n  parseClosureTemplateTag\n};\n"],"file":"jsdocUtils.js"}